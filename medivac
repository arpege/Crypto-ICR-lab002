#!/usr/bin/env python3

import sys
import os
import zipfile
import Crypto

from Crypto.Hash import SHA256
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA

# temp filename for compression
ZIP_FILENAME = 'medfile.zip'

# result filename can't be choose
MED_FILENAME = 'medfile.medivac'

# define header print
def printHead () :
  print ( """  __  __          _ _                 
 |  \/  |        | (_)                
 | \  / | ___  __| |___   ____ _  ___ 
 | |\/| |/ _ \/ _` | \ \ / / _` |/ __|
 | |  | |  __/ (_| | |\ V / (_| | (__ 
 |_|  |_|\___|\__,_|_| \_/ \__,_|\___|""" )
  
def printHeadCrypt () :
  print ( """  ___                       _   
 | __|_ _  __ _ _ _  _ _ __| |_ 
 | _|| ' \/ _| '_| || | '_ \  _|
 |___|_||_\__|_|  \_, | .__/\__|
                  |__/|_|       
                  
                  """ )
  
def printHeadDecrypt () :
  
  print ( """  ___                       _   
 |   \ ___ __ _ _ _  _ _ __| |_ 
 | |) / -_) _| '_| || | '_ \  _|
 |___/\___\__|_|  \_, | .__/\__|
                  |__/|_|       
                  
                  """ )
# display the help
def printMan () :
  print ( """
  Medivac version 1.0
  Author: Joel Gugger <joel.gugger@master.hes-so.ch>
  
  Usage:  medivac source_file ...
          medivac -d medivac_file [output_directory]
  """ )

# Encrypt function
# args contains an array of file name
# that will be compressed with zipfile
# The zipfile result is crypted and 
# save in medfile.medivac
def encrypt ( private_key, args ) :
  
  printHeadCrypt()
  
  key = None
  if os.path.isfile( private_key ) :
    f = open( private_key, 'r' )
    key = RSA.importKey( f.read() )
    f.close()
  
  if os.path.isfile( ZIP_FILENAME ) :
    print ( '  ' + ZIP_FILENAME + ' already exist!' )
    print ( '  Removing file ' + ZIP_FILENAME )
    os.remove( ZIP_FILENAME )
  
  print ( """\n  Start compresion...\n""" )
  with zipfile.ZipFile(ZIP_FILENAME, 'x') as medzip :
    for medFile in args:
      if os.path.isfile( medFile ) :
        print ( '   * Adding ' + str ( medFile)  )
        medzip.write( str ( medFile) )
    medzip.close()
  print ( """\n\n  Start encryption...\n""" )
  
  fh = open( ZIP_FILENAME, 'rb' )
  try :
    #ba = bytearray( fh.read() )
    plaintext = fh.read()
    print ( plaintext )
    
    publickey = key.publickey()
    
    encrypted = publickey.encrypt(plaintext, 32)[0]
    print (encrypted)
    
    print ( """\n\n  Finish encryption...\n""" )
    
    #print ( key.exportKey() )
    #print ( publickey.exportKey() )
    
    #iv = os.urandom(16)
    #print (iv)
    
    #obj = AES.new('This is a key123', AES.MODE_CBC, iv )
    #ciphertext = obj.encrypt( '0123456789abcdef' )
    
    #print ( ciphertext ) 
    
    # TODO encrypt the file
    # ...
    
    # TODO store the creation date on the file
    # TODO make a HMAC after encryption
    
    with open( MED_FILENAME, 'wb' ) as f :
      f.write( encrypted )
      f.close()
    
  finally :
    fh.close()
  
  print ( """\n  Removing temp files...\n""" )
  if os.path.isfile( ZIP_FILENAME ) :
    os.remove( ZIP_FILENAME )
    print ( '   * ' + ZIP_FILENAME + ' removed' )
  
  print ( """
   ----------------------------------------
  | Medivac encryption finish with success |
   ----------------------------------------
  """ )
  

# Decrypt function
# Read the file in args[0]
# check the signature and decrypt bytes
# Create the zip temp file and unzip it
# Output the result in args[1] if
# args[1] is a directory, else in '.'
def decrypt ( private_key, args ) :
  
  printHeadDecrypt()
  
  key = None
  if os.path.isfile( private_key ) :
    f = open( private_key, 'r' )
    key = RSA.importKey( f.read() )
    f.close()
  
  
  if len( args ) < 1 or len( args ) > 2 :
    print ( """  > Number of args incorect, exit decryption proccess\n""" )
    sys.exit( 0 )
  
  medfile = str( args[0] )
  
  try:
    output = str( args[1] )
    if not os.path.isdir( output ) :
      output = '.'
  except IndexError:
    output = '.'
  
  if ( os.path.isfile( medfile ) ) :
    print ( '  Reading file ' + medfile )
    print ( '  Output result in ' + output + '\n' )
    
    fh = open( medfile, 'rb' )
    try :
      b = fh.read()

      print ( b )
      
      plaintext = key.decrypt( b )
      print ( plaintext ) 
      
      # TODO check HMAC and filename
      # TODO check creation/modification date
      # TODO decrypt bytes
      # ...
      
      if os.path.isfile( ZIP_FILENAME ) :
        print ( '  ' + ZIP_FILENAME + ' already exist!' )
        print ( '  Removing file ' + ZIP_FILENAME )
        os.remove( ZIP_FILENAME )
    
      with open( ZIP_FILENAME, 'wb' ) as f :
        f.write( plaintext )
        f.close()
      
      with zipfile.ZipFile( ZIP_FILENAME ) as medzip:
        if medzip.testzip() == None :
          medzip.extractall( output )
        medzip.close()
      
      print ( """\n  Removing temp files...\n""" )
      os.remove( ZIP_FILENAME )
      print ( '   * ' + ZIP_FILENAME + ' removed' )

    finally :
      fh.close()
    
  else :
    print ( """  > File not exist, exit decryption proccess\n""" ) 
    sys.exit( 0 )
  
  print ( """
   ----------------------------------------
  | Medivac decryption finish with success |
   ----------------------------------------
  """ )

# Main function
# Test sys args and call the correct function
def main () :
  
  if len( sys.argv ) == 1 or sys.argv[1] == '-h' or sys.argv[1] == '--help' :
    printMan()
  else :
    if sys.argv[1] == '-d' :
      decrypt ( sys.argv[2], sys.argv[3:] )
    else :
      encrypt ( sys.argv[1], sys.argv[2:] )
  
  
if __name__ == '__main__' :
  
  printHead()
  main()
  